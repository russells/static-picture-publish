#!/usr/bin/python

from sys import exit, stderr
from os import listdir, makedirs, rmdir, stat, unlink
from os.path import basename, isdir, join, splitext
from optparse import OptionParser, Option, OptionValueError
from copy import copy
import Image
from errno import ENOENT
from urllib import quote, quote_plus
from StringIO import StringIO


defaultExtensions = '.jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.png,.PNG'

class SppOption(Option):
    '''Extend OptionParser to parse image dimension specifications (AxB).'''

    def check_intpair(option, opt, value):
        intstrs = value.split('x')
        try:
            if len(intstrs) == 1:
                i = int(intstrs[0])
                ints = (i,i)
            elif len(intstrs) == 2:
                ints = ( int(intstrs[0]), int(intstrs[1]) )
            else:
                raise OptionValueError(
                    "option %s: Must be one int or two ints AxB: %r" % \
                    (opt, value))
        except ValueError,reason:
            raise OptionValueError(
                "option %s: not an integer or integer pair: %s" % (opt, value))
        return ints

    TYPES = Option.TYPES + ("intpair",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["intpair"] = check_intpair


opt = OptionParser(
option_class=SppOption,
version="%prog 0.1",
usage=
'Usage: %prog [options] picdir webdir.\n'
'  Recursively publish pics from picdir into webdir\n'
'\n'
'  Directories and pics from picdir will be mirrored into webdir, as\n'
'  thumbnails and small copies.  Symlinks will be used to point to the\n'
'  originals in picdir.\n'
'\n'
'  %prog can be run multiple times with the same picdir\n'
'  and webdir.  Pre-existing content in picdir that is still current will\n'
'  not have its webdir output regenerated.  Directories and images in picdir\n'
'  that no longer exist will have their equivalents removed from webdir.')

opt.add_option('-c','--copy',
               action='store_true',
               help='Copy originals instead of symlinking')
opt.add_option('--css',
               action='store',
               metavar="css_file",
               help='CSS file to use in html')
opt.add_option('-e','--extensions',
               action='store',
               help='Comma-separated list of file extensions to use.  '
               'Default is "%s".  '
               'If you modify this, be sure to include upper and lower case '
               'versions of the extensions.' % defaultExtensions)
opt.add_option('-g','--regen-html',
               action='store_true',
               help='Force regeneration of HTML output')
opt.add_option('-n','--no-symlink',
               action='store_true',
               help='Don\'t symlink originals')
opt.add_option('-q','--quiet',
               action='store_true',
               help='Don\'t print any output')
opt.add_option('-r','--regen-all',
               action='store_true',
               help='Force regeneration of all output')
opt.add_option('-s','--image-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for images (default 800x800 pixels)')
opt.add_option('-t','--title',
               type='string',
               action='store',
               help='Set the HTML title')
opt.add_option('-v','--verbose',
               action='store_true',
               help='Print more information about actions')
opt.add_option('-z','--thumbnail-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for thumbnails (default 128x128 pixels)')

def parseOptions():
    global options, picRoot, webRoot, picTree, webTree
    (options, args) = opt.parse_args()
    if len(args) != 2:
        usage()
    if options.extensions:
        options.extensions = options.extensions.split(',')
    else:
        options.extensions = defaultExtensions.split(',')
    if not options.image_size:
        options.image_size = (800,800)
    if not options.thumbnail_size:
        options.thumbnail_size = (128,128)
    options.messageLevel = 1
    if options.verbose:
        options.messageLevel = 0
    if options.quiet:
        options.messageLevel = 2
    picRoot = args[0]
    webRoot = args[1]


def usage(errcode=1):
    opt.print_help(stderr)
    exit(errcode)


def message(msg, level=1):
    if level <= options.messageLevel:
        print msg


entityChars = { '&':"amp", '<':"lt", '>':"gt", '\'':"apos", '"':"quot" }

def entityReplace(s):
    '''Replace the characters "&<>\'" with html entities.'''
    r = StringIO()
    for c in s:
        if c in entityChars:
            r.write("&%s;" % entityChars[c])
        else:
            r.write(c)
    s2 = r.getvalue()
    r.close()
    return s2


class Picture:
    '''Process one pic.'''
    def __init__(self, picName, picDirName, webDirName):
        self.picName = picName
        self.picDirName = picDirName
        self.webDirName = webDirName
        self.picPath = join(picDirName, picName)
        (base, ext) = splitext(self.picName)
        self.imageName = picName
        self.fullImageName = base + "-full" + ext
        self.imagePath = join(webDirName, self.imageName)
        self.thumbnailName = base + "-thumb" + ext
        self.thumbnailPath = join(webDirName, self.thumbnailName)
        self.htmlName = base + ".html"
        self.htmlPath = join(webDirName, self.htmlName)

    def go(self, prevPic, nextPic):
        '''Create the output files (thumbnail, image and html).'''

        if not options.regen_all:
            picStat = stat(self.picPath)

        modified = False
        im = None
        try:
            # Create the web image, if necessary.
            if options.regen_all or not fileIsNewer(self.imagePath, picStat):
                message("  %s => %s" % (self.picPath, self.imagePath))
                im = Image.open(self.picPath)
                imwe = im.copy()
                imwe.thumbnail(options.image_size, Image.ANTIALIAS)
                imwe.save(self.imagePath)
                imwe = None                 # gc
                modified = True
            # Create the thumbnail, if necessary.
            if options.regen_all \
                   or not fileIsNewer(self.thumbnailPath, picStat):
                message("  %s => %s" % (self.picPath, self.thumbnailPath))
                if im is None:
                    im = Image.open(self.picPath)
                im.thumbnail(options.thumbnail_size, Image.ANTIALIAS)
                im.save(self.thumbnailPath)
                modified = True
                im = None                   # gc
        except IOError, reason:
            print >>stderr, "Error processing %s: %s" % \
                  (self.picPath, str(reason.args))
        self.createHTML(prevPic, nextPic)
        return modified

    def createHTML(self, prevPic, nextPic):
        '''Make the HTML file for one picture.

        This includes links to the previous and next pictures.'''

        message("  %s => %s" % (self.picPath, self.htmlPath))
        htmlFile = file(self.htmlPath, "w")
        print >>htmlFile, '<!DOCTYPE html ' \
              'PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
              '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
        print >>htmlFile, \
              '<html xmlns="http://www.w3.org/1999/xhtml">\n<head>'
        print >>htmlFile, '<title>%s</title>' % self.picName
        print >>htmlFile, '</head><body>'
        print >>htmlFile, '<img src="%s"/>' % quote_plus(self.picName,'/')
        print >>htmlFile, '</body></html>'
        htmlFile.close()


class PictureDir:
    '''Contains information about a picture directory.'''
    def __init__(self, picRoot, webRoot, dirName='', doUp=False):
        '''Search through the directory, looking for pictures and
        sub-directories.  We do not process anything yet, but wait until we
        know if the subdirs contain anything interesting.'''
        self.picRoot = picRoot
        self.webRoot = webRoot
        self.dirName = dirName          # Relative to picRoot (and webRoot)
        self.doUp = doUp                # If true, put "Up" link in html

        if self.dirName=='':
            self.picPath = self.picRoot
            self.webPath = self.webRoot
        else:
            self.picPath = join(self.picRoot, self.dirName)
            self.webPath = join(self.webRoot, self.dirName)
        self.subdirList = []
        self.picList = []
        # Now create our lists
        lst = listdir(self.picPath)
        for l in lst:
            # If it's a directory, recursively create an instance and process
            # that directory.
            subPath = join(self.picPath, l)
            if isdir(subPath):
                p = PictureDir(self.picRoot, self.webRoot,
                               join(self.dirName,l), True)
                if p.hasPics():
                    self.subdirList.append(p)
            elif isPicFile(self.picPath, subPath):
                self.picList.append(Picture(l, self.picPath, self.webPath))
        message("  %s" % self, 2)


    def __str__(self):
        s = '<<PictureDir("%s","%s","%s",%s)' % \
            (self.picRoot, self.webRoot, self.dirName, str(self.doUp))
        s += ':im=[ '
        for p in self.picList:
            s = s + p.picName + ' '
        s = s + ']'
        s = s + ':sd[ '
        for d in self.subdirList:
            s = s + d.dirName+' '
        s = s + ']>>'
        return s


    def hasPics(self):
        return len(self.subdirList) > 0 or len(self.picList) > 0


    def go(self):
        '''Process the pics and sub-directories.'''
        if not self.hasPics():
            message("No pics in %s: doing nothing" % self.picPath)
            return False
        message("%s" % self.picPath)
        if not isdir(self.webPath):
            makedirs(self.webPath)
        modified = False
        for i in range(len(self.picList)):
            pic = self.picList[i]
            if i > 0: prevPic = self.picList[i-1]
            else: prevPic = None
            if i < len(self.picList)-1: nextPic = self.picList[i+1]
            else: nextPic = None
            m = pic.go(prevPic, nextPic)
            if m: modified = True
        for d in self.subdirList:
            m = d.go()
            if m: modified = True
        if options.regen_all or options.regen_html or modified:
            # Create our directory index
            self.createHTML()
        return modified


    def createHTML(self):
        '''Create the html output for a directory.'''

        htmlFileName = join(self.webPath, "index.html")
        message("  %s" % htmlFileName, 0)
        htmlFile = file(htmlFileName, "w")
        print >>htmlFile, '<!DOCTYPE html ' \
              'PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
              '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
        print >>htmlFile, \
              '<html xmlns="http://www.w3.org/1999/xhtml">\n<head>'
        if self.dirName == '': title = "Pics"
        else:                  title = "Pics - %s" % self.dirName
        print >>htmlFile, '<title>%s</title>' % title
        print >>htmlFile, '</head><body>'
        print >>htmlFile, '<h1 class="maintitle">%s</h1>' % title
        if self.doUp:
            print >>htmlFile, '<a class="uplink" href="..">Up</a><br/>'
        for d in self.subdirList:
            print >>htmlFile, '<a class="dirlink" href="%s">%s</a><br/>' % \
                  (quote_plus(basename(d.dirName),'/')+'/',
                   entityReplace(d.dirName))
        for p in self.picList:
            print >>htmlFile, '<a class="piclink" href="%s">' \
                  '<img class="piclinkimg" src="%s" />' \
                  '<span class="piclinkspan">%s</span></a><br/>' % \
                  (quote_plus(p.htmlName,'/'), quote_plus(p.thumbnailName),
                   entityReplace(p.imageName))
        print >>htmlFile, "</body></html>"
        htmlFile.close()


def dirTree(rootName='.'):
    '''Return a list of directory names starting from a specified root.'''

    def recursiveDirTree(rootName,dirName):
        '''Return a list of directory names.

        The directories are searched for starting from rootName/dirName.  The
        "rootName/" prefix is not included in names in the list.  dirName is
        included in the list.'''
        lst = []
        dirList = listdir(join(rootName,dirName))
        for d in dirList:
            if isdir(join(rootName,dirName,d)):
                dName = join(dirName,d)
                #message("Appending (%s) %s" % (rootName,dName))
                lst.append(dName)
                lst.extend(recursiveDirTree(rootName,dName))
        return lst

    lst = []
    if not isdir(rootName):
        return lst
    #message("Appending (%s) ." % rootName)
    lst.append('.')
    thisDirList = listdir(rootName)
    for subd in thisDirList:
        if isdir(join(rootName,subd)):
            #message("Appending (%s) %s" % (rootName,subd))
            lst.append(subd)
            lst.extend(recursiveDirTree(rootName,subd))
    return lst


def isPicFile(path, pic):
    '''Determine if a file is a known picture type.

    This currently only looks at the file name (actually the extension).  It
    should also identify the file contents, perhaps using Image methods?'''

    (base, ext) = splitext(pic)
    if ext in options.extensions:
        return True
    return False


def fileIsNewer(file1, file2):
    '''Return true if first named file is newer than the second.

    file1 and file2 can be names, or the results of calling os.stat().  If
    either file does not exist, we return false.'''
    if isinstance(file1,str):
        try:
            file1stat = stat(file1)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file1stat = file1
    if isinstance(file2,str):
        try:
            file2stat = stat(file2)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file2stat = file2
    return file1stat.st_mtime > file2stat.st_mtime


def doWebDirs():
    for d in webTree:
        # Handle '.' specially.  This is slightly icky.
        if d == '.':
            webd = webRoot
            picd = picRoot
        else:
            webd = join(webRoot, d)
            picd = join(picRoot, d)
        doOneWebDir(webd, picd)


def doOneWebDir(webd, picd):
    # First check that the directory still exists.
    if not isdir(webd):
        return
    if not isdir(picd):
        # There is no corresponding picture directory, so we recursively delete
        # the web output dir.
        deleteDir(webd)


def deleteDir(d):
    '''Recursively delete a whole directory tree.'''
    lst = listdir(d)
    for e in lst:
        p = join(d,e)
        if isdir(p):
            deleteDir(p)
        else:
            unlink(p)
    message("Removing directory %s" % d)
    rmdir(d)


if __name__ == '__main__':
    parseOptions()

    pd = PictureDir(picRoot, webRoot)
    pd.go()

    global webTree
    webTree = dirTree(webRoot)
    doWebDirs()

# arch-tag: dbd38a8f-6259-49ca-a125-6b5cd1f48bdb

