#!/usr/bin/python

import sys
import os
from optparse import OptionParser, Option, OptionValueError
from copy import copy
import Image
from errno import ENOENT
from types import StringType


defaultExtensions = '.jpg,.JPG,.gif,.GIF,.png,.PNG'

class SppOption(Option):
    '''Extend OptionParser to parse image dimension specifications (AxB).'''

    def check_intpair(option, opt, value):
        intstrs = value.split('x')
        try:
            if len(intstrs) == 1:
                i = int(intstrs[0])
                ints = (i,i)
            elif len(intstrs) == 2:
                ints = ( int(intstrs[0]), int(intstrs[1]) )
            else:
                raise OptionValueError(
                    "option %s: Must be one int or two ints AxB: %r" % \
                    (opt, value))
        except ValueError,reason:
            raise OptionValueError(
                "option %s: not an integer or integer pair: %s" % (opt, value))
        return ints

    TYPES = Option.TYPES + ("intpair",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["intpair"] = check_intpair


opt = OptionParser(
option_class=SppOption,
version="%prog 0.1",
usage=
'Usage: %prog [options] picdir webdir.\n'
'  Recursively publish pics from picdir into webdir\n'
'\n'
'  Directories and pics from picdir will be mirrored into webdir, as\n'
'  thumbnails and small copies.  Symlinks will be used to point to the\n'
'  originals in picdir.\n'
'\n'
'  %prog can be run multiple times with the same picdir\n'
'  and webdir.  Pre-existing content in picdir that is still current will\n'
'  not have its webdir output regenerated.  Directories and images in picdir\n'
'  that no longer exist will have their equivalents removed from webdir.')

opt.add_option('-c','--copy',
               action='store_true',
               help='Copy originals instead of symlinking')
opt.add_option('--css',
               action='store',
               metavar="css_file",
               help='CSS file to use in html')
opt.add_option('-e','--extensions',
               action='store',
               help='Comma-separated list of file extensions to use.  '
               'Default is "%s".  '
               'If you modify this, be sure to include upper and lower case '
               'versions of the extensions.' % defaultExtensions)
opt.add_option('-n','--no-symlink',
               action='store_true',
               help='Don\'t symlink originals')
opt.add_option('-q','--quiet',
               action='store_true',
               help='Don\'t print any output')
opt.add_option('-r','--regenerate',
               action='store_true',
               help='Force regeneration of all output')
opt.add_option('-s','--image-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for images (default 800x800 pixels)')
opt.add_option('-t','--thumbnail-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for thumbnails (default 128x128 pixels)')
opt.add_option('-v','--verbose',
               action='store_true',
               help='Print more information about actions')

def parseOptions():
    global options, picRoot, webRoot, picTree, webTree
    (options, args) = opt.parse_args()
    if len(args) != 2:
        usage()
    if options.extensions:
        options.extensions = options.extensions.split(',')
    else:
        options.extensions = defaultExtensions.split(',')
    if not options.image_size:
        options.image_size = (800,800)
    if not options.thumbnail_size:
        options.thumbnail_size = (128,128)
    options.messageLevel = 1
    if options.verbose:
        options.messageLevel = 0
    if options.quiet:
        options.messageLevel = 2
    picRoot = args[0]
    webRoot = args[1]


def usage(errcode=1):
    opt.print_help(sys.stderr)
    sys.exit(errcode)


def message(msg, level=1):
    if level >= options.messageLevel:
        print msg


def dirTree(rootName='.'):
    '''Return a list of directory names starting from a specified root.'''

    def recursiveDirTree(rootName,dirName):
        '''Return a list of directory names.

        The directories are searched for starting from rootName/dirName.  The
        "rootName/" prefix is not included in names in the list.  dirName is
        included in the list.'''
        lst = []
        dirList = os.listdir(os.path.join(rootName,dirName))
        for d in dirList:
            if os.path.isdir(os.path.join(rootName,dirName,d)):
                dName = os.path.join(dirName,d)
                #message("Appending (%s) %s" % (rootName,dName))
                lst.append(dName)
                lst.extend(recursiveDirTree(rootName,dName))
        return lst

    lst = []
    if not os.path.isdir(rootName):
        return lst
    #message("Appending (%s) ." % rootName)
    lst.append('.')
    thisDirList = os.listdir(rootName)
    for subd in thisDirList:
        if os.path.isdir(os.path.join(rootName,subd)):
            #message("Appending (%s) %s" % (rootName,subd))
            lst.append(subd)
            lst.extend(recursiveDirTree(rootName,subd))
    return lst


def doPictureDirs():
    for d in picTree:
        # Handle '.' specially.  This is slightly icky.
        if d == '.':
            picd = picRoot
            webd = webRoot
        else:
            picd = os.path.join(picRoot, d)
            webd = os.path.join(webRoot, d)
        doOnePictureDir(picd, webd)


def doOnePictureDir(picd, webd):
    '''Create one web dir from one picture dir.

    In here, the paths are full paths to the directories, so files can be
    opened using those paths, etc.  The roots have already been prepended.'''

    message(picd)
    if not os.path.isdir(webd):
        message("  Creating %s" % webd)
        os.makedirs(webd)
    piclist = os.listdir(picd)
    for pic in piclist:
        if isPicFile(os.path.join(picd,pic)):
            #print "pic=",pic
            doOnePicture(picd, pic, webd)


def isPicFile(pic):
    (base, ext) = os.path.splitext(pic)
    if ext in options.extensions:
        return True
    return False


def doOnePicture(picd, pic, webd):
    '''Create the thumbnail and html file for one pic.

    '''
    (base, ext) = os.path.splitext(pic)
    if not ext in options.extensions:
        raise Exception("Pic with unhandled extension: %s" % pic)
    picPath = os.path.join(picd,pic)
    if not options.regenerate:
        picStat = os.stat(picPath)

    im = None
    # Create the web image, if necessary.
    imageName = os.path.join(webd, base + "-small" + ext)
    if options.regenerate or not fileIsNewer(imageName, picStat):
        print "  %s => %s" % (picPath, imageName)
        im = Image.open(picPath)
        imwe = im.copy()
        imwe.thumbnail(options.image_size, Image.ANTIALIAS)
        imwe.save(imageName)
        imwe = None                     # gc
    # Create the thumbnail, if necessary.
    thumbnailName = os.path.join(webd, base + "-thumb" + ext)
    if options.regenerate or not fileIsNewer(thumbnailName, picStat):
        print "  %s => %s" % (picPath, thumbnailName)
        if im is None:
            im = Image.open(picPath)
        im.thumbnail(options.thumbnail_size, Image.ANTIALIAS)
        im.save(thumbnailName)
    im = None                           # gc


def fileIsNewer(file1, file2):
    '''Return true if first named file is newer than the second.

    file1 and file2 can be names, or the results of calling os.stat().  If
    either file does not exist, we return false.'''
    if isinstance(file1,str):
        try:
            file1stat = os.stat(file1)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file1stat = file1
    if isinstance(file2,str):
        try:
            file2stat = os.stat(file2)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file2stat = file2
    return file1stat.st_mtime > file2stat.st_mtime


def doWebDirs():
    for d in webTree:
        # Handle '.' specially.  This is slightly icky.
        if d == '.':
            webd = webRoot
            picd = picRoot
        else:
            webd = os.path.join(webRoot, d)
            picd = os.path.join(picRoot, d)
        doOneWebDir(webd, picd)


def doOneWebDir(webd, picd):
    # First check that the directory still exists.
    if not os.path.isdir(webd):
        return
    if not os.path.isdir(picd):
        # There is no corresponding picture directory, so we recursively delete
        # the web output dir.
        deleteDir(webd)


def deleteDir(d):
    '''Recursively delete a whole directory tree.'''
    lst = os.listdir(d)
    for e in lst:
        p = os.path.join(d,e)
        if os.path.isdir(p):
            deleteDir(p)
        else:
            os.unlink(p)
    message("Removing directory %s" % d)
    os.rmdir(d)


if __name__ == '__main__':
    global picTree, webTree
    parseOptions()
    picTree = dirTree(picRoot)
    webTree = dirTree(webRoot)
    #print "picTree=",picTree
    #print "webTree=",webTree

    doPictureDirs()
    doWebDirs()



# arch-tag: dbd38a8f-6259-49ca-a125-6b5cd1f48bdb

