#!/usr/bin/python

from sys import exit, stderr
from os import listdir, makedirs, rmdir, stat, unlink
from os.path import basename, isdir, join as pathjoin, splitext
from optparse import OptionParser, Option, OptionValueError
from copy import copy
import Image
from errno import ENOENT
#from urllib import quote, quote_plus
from StringIO import StringIO
from string import join as stringjoin


defaultExtensions = '.jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.png,.PNG'


inlineCSS = \
'''div.thumbnaildiv                  { display:inline; }\n'''


class SppOption(Option):
    '''Extend OptionParser to parse image dimension specifications (AxB).'''

    def check_intpair(option, opt, value):
        intstrs = value.split('x')
        try:
            if len(intstrs) == 1:
                i = int(intstrs[0])
                ints = (i,i)
            elif len(intstrs) == 2:
                ints = ( int(intstrs[0]), int(intstrs[1]) )
            else:
                raise OptionValueError(
                    "option %s: Must be one int or two ints AxB: %r" % \
                    (opt, value))
        except ValueError,reason:
            raise OptionValueError(
                "option %s: not an integer or integer pair: %s" % (opt, value))
        return ints

    TYPES = Option.TYPES + ("intpair",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["intpair"] = check_intpair


opt = OptionParser(
option_class=SppOption,
version="%prog 0.1",
usage=
'Usage: %prog [options] picdir webdir.\n'
'  Recursively publish pics from picdir into webdir\n'
'\n'
'  Directories and pics from picdir will be mirrored into webdir, as\n'
'  thumbnails and small copies.  Symlinks will be used to point to the\n'
'  originals in picdir.\n'
'\n'
'  %prog can be run multiple times with the same picdir\n'
'  and webdir.  Pre-existing content in picdir that is still current will\n'
'  not have its webdir output regenerated.  Directories and images in picdir\n'
'  that no longer exist will have their equivalents removed from webdir.')

opt.add_option('-c','--copy',
               action='store_true',
               help='Copy originals instead of symlinking')
opt.add_option('--css',
               action='store',
               metavar="css_file",
               help='CSS file to use in html')
opt.add_option('-e','--extensions',
               action='store',
               help='Comma-separated list of file extensions to use.  '
               'Default is "%s".  '
               'If you modify this, be sure to include upper and lower case '
               'versions of the extensions.' % defaultExtensions)
opt.add_option('-g','--regen-html',
               action='store_true',
               help='Force regeneration of HTML output')
opt.add_option('-n','--no-symlink',
               action='store_true',
               help='Don\'t symlink originals')
opt.add_option('-q','--quiet',
               action='store_true',
               help='Don\'t print any output')
opt.add_option('-r','--regen-all',
               action='store_true',
               help='Force regeneration of all output')
opt.add_option('--row',
               type='int',
               action='store',
               help='Number of images per row in HTML. (default 3)')
opt.add_option('-s','--image-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for images (default 800x800 pixels)')
opt.add_option('-t','--title',
               type='string',
               action='store',
               help='Set the HTML title')
opt.add_option('-v','--verbose',
               action='store_true',
               help='Print more information about actions')
opt.add_option('-x','--xml',
               action='store_true',
               help='Create XML files, that will be transformed with XSLT '
               'in the browser, instead of plain HTML. (unimplemented)')
opt.add_option('-z','--thumbnail-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for thumbnails (default 128x128 pixels)')

def parseOptions():
    global options, picRoot, webRoot, picTree, webTree
    (options, args) = opt.parse_args()
    if len(args) != 2:
        usage()
    if options.extensions:
        options.extensions = options.extensions.split(',')
    else:
        options.extensions = defaultExtensions.split(',')
    if not options.image_size:
        options.image_size = (800,800)
    if not options.thumbnail_size:
        options.thumbnail_size = (128,128)
    options.messageLevel = 1
    if options.verbose:
        options.messageLevel = 0
    if options.quiet:
        options.messageLevel = 2
    if not options.row:
        options.row = 3
    picRoot = args[0]
    webRoot = args[1]


def usage(errcode=1):
    opt.print_help(stderr)
    exit(errcode)


def message(msg, level=1):
    if level <= options.messageLevel:
        print msg


entityChars = { '&':"amp", '<':"lt", '>':"gt", '\'':"apos", '"':"quot" }

def entityReplace(s):
    '''Replace the characters "&<>\'" with html entities.'''
    r = StringIO()
    for c in s:
        if c in entityChars:
            r.write("&%s;" % entityChars[c])
        else:
            r.write(c)
    s2 = r.getvalue()
    r.close()
    return s2


class Picture:
    '''Process one pic.'''
    def __init__(self, picName, picDirName, webDirName):
        self.picName = picName
        self.picDirName = picDirName
        self.webDirName = webDirName
        self.picPath = pathjoin(picDirName, picName)
        (base, ext) = splitext(self.picName)
        self.imageName = picName
        self.fullImageName = base + "-full" + ext
        self.imagePath = pathjoin(webDirName, self.imageName)
        self.thumbnailName = base + "-thumb" + ext
        self.thumbnailPath = pathjoin(webDirName, self.thumbnailName)
        self.htmlName = base + ".html"
        self.htmlPath = pathjoin(webDirName, self.htmlName)

    def go(self, prevPic, nextPic):
        '''Create the output files (thumbnail, image and html).'''

        if not options.regen_all:
            picStat = stat(self.picPath)

        modified = False
        im = None
        try:
            # Create the web image, if necessary.
            if options.regen_all or not fileIsNewer(self.imagePath, picStat):
                message("  %s => %s" % (self.picPath, self.imagePath))
                im = Image.open(self.picPath)
                imwe = im.copy()
                imwe.thumbnail(options.image_size, Image.ANTIALIAS)
                imwe.save(self.imagePath)
                imwe = None                 # gc
                modified = True
            # Create the thumbnail, if necessary.
            if options.regen_all \
                   or not fileIsNewer(self.thumbnailPath, picStat):
                message("  %s => %s" % (self.picPath, self.thumbnailPath))
                if im is None:
                    im = Image.open(self.picPath)
                im.thumbnail(options.thumbnail_size, Image.ANTIALIAS)
                im.save(self.thumbnailPath)
                modified = True
                im = None                   # gc
        except IOError, reason:
            print >>stderr, "Error processing %s: %s" % \
                  (self.picPath, str(reason.args))
        self.createHTML(prevPic, nextPic)
        return modified

    def createHTML(self, prevPic, nextPic):
        '''Make the HTML file for one picture.

        This includes links to the previous and next pictures.'''

        message("  %s => %s" % (self.picPath, self.htmlPath))
        h = file(self.htmlPath, "w")
        print >>h, '<!DOCTYPE html ' \
              'PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
              '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
        print >>h, \
              '<html xmlns="http://www.w3.org/1999/xhtml">\n<head>'
        print >>h, '<meta http-equiv="Content-type" ' \
              'content="text/html; charset=UTF-8" />'
        print >>h, '<title>%s</title>' % self.picName
        print >>h, '</head><body>'
        print >>h, '<h1 class="picheading">%s</h1>' % entityReplace(self.picName)
        print >>h, '<div class="prevnextlinks">'
        if prevPic is not None:
            print >>h, '<a class="prevlink" href="%s">Previous (%s)</a>' % \
                  (entityReplace(prevPic.htmlName),
                   entityReplace(prevPic.picName))
        print >>h, '<a class="indexlink" href=".">Index</a>'
        if nextPic is not None:
            print >>h, '<a class="nextlink" href="%s">Next (%s)</a>' % \
                  (entityReplace(nextPic.htmlName),
                   entityReplace(nextPic.picName))
        print >>h, '</div>'
        print >>h, '<img class="pic" src="%s" alt="%s" />' % \
              (entityReplace(self.picName), entityReplace(self.picName))
        print >>h, '</body></html>'
        h.close()

    def __eq__(self, other): return self.picName == other.picName
    def __ne__(self, other): return self.picName != other.picName
    def __gt__(self, other): return self.picName >  other.picName
    def __lt__(self, other): return self.picName <  other.picName
    def __ge__(self, other): return self.picName >= other.picName
    def __le__(self, other): return self.picName <= other.picName


class PictureDir:
    '''Contains information about a picture directory.'''
    def __init__(self, picRoot, webRoot, dirName='', doUp=False):
        '''Search through the directory, looking for pictures and
        sub-directories.  We do not process anything yet, but wait until we
        know if the subdirs contain anything interesting.'''
        self.picRoot = picRoot
        self.webRoot = webRoot
        self.dirName = dirName          # Relative to picRoot (and webRoot)
        self.dirBasename = basename(dirName)
        self.doUp = doUp                # If true, put "Up" link in html

        if self.dirName=='':
            self.picPath = self.picRoot
            self.webPath = self.webRoot
        else:
            self.picPath = pathjoin(self.picRoot, self.dirName)
            self.webPath = pathjoin(self.webRoot, self.dirName)
        self.subdirList = []
        self.picList = []
        # Now create our lists
        lst = listdir(self.picPath)
        for l in lst:
            # If it's a directory, recursively create an instance and process
            # that directory.
            subPath = pathjoin(self.picPath, l)
            if isdir(subPath):
                p = PictureDir(self.picRoot, self.webRoot,
                               pathjoin(self.dirName,l), True)
                if p.hasPics():
                    self.subdirList.append(p)
            elif isPicFile(self.picPath, subPath):
                self.picList.append(Picture(l, self.picPath, self.webPath))
        self.picList.sort()
        self.subdirList.sort()

    def __str__(self):
        s = '<<PictureDir("%s","%s","%s",%s)' % \
            (self.picRoot, self.webRoot, self.dirName, str(self.doUp))
        s += ':im=[ '
        for p in self.picList:
            s = s + p.picName + ' '
        s = s + ']'
        s = s + ':sd[ '
        for d in self.subdirList:
            s = s + d.dirName+' '
        s = s + ']>>'
        return s


    def hasPics(self):
        return len(self.subdirList) > 0 or len(self.picList) > 0


    def go(self):
        '''Process the pics and sub-directories.'''
        if not self.hasPics():
            message("No pics in %s: doing nothing" % self.picPath)
            return False
        message("%s" % self.picPath)
        if not isdir(self.webPath):
            makedirs(self.webPath)
        modified = False
        for i in range(len(self.picList)):
            pic = self.picList[i]
            if i > 0: prevPic = self.picList[i-1]
            else: prevPic = None
            if i < len(self.picList)-1: nextPic = self.picList[i+1]
            else: nextPic = None
            m = pic.go(prevPic, nextPic)
            if m: modified = True
        for d in self.subdirList:
            m = d.go()
            if m: modified = True
        if options.regen_all or options.regen_html or modified:
            # Create our directory index
            self.createHTML()
        return modified

    numberClasses = { 2:'p2', 3:'p3', 4:'p4', 5:'p5' }

    def createHTML(self):
        '''Create the html output for a directory.'''

        htmlFileName = pathjoin(self.webPath, "index.html")
        message("  %s" % htmlFileName, 0)
        h = file(htmlFileName, "w")
        print >>h, '<!DOCTYPE html ' \
              'PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
              '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
        print >>h, \
              '<html xmlns="http://www.w3.org/1999/xhtml">\n<head>'
        if self.dirName == '': title = "Pics"
        else:                  title = "Pics - %s" % self.dirName
        print >>h, '<meta http-equiv="Content-type" ' \
              'content="text/html; charset=UTF-8" />'
        print >>h, '<title>%s</title>' % title
        print >>h, '<style type="text/css">'
        print >>h, inlineCSS
        print >>h, '</style>'
        print >>h, '</head><body>'
        print >>h, '<h1 class="maintitle">%s</h1>' % title
        if self.doUp:
            print >>h, '<a class="uplink" href="..">Up</a><br/>'
        for d in self.subdirList:
            print >>h, '<a class="dirlink" href="%s">%s</a><br/>' % \
                  (entityReplace(d.dirBasename)+'/',
                   entityReplace(d.dirBasename))
        for i in range(len(self.picList)):
            p = self.picList[i]
            divClass = ['thumbnaildiv']
            for nth in range(2,6):
                if i%nth==nth-1:
                    divClass.append(self.numberClasses[nth])
            if i%options.row == 0:
                print >>h, '<div class="thumbnailrow">'
            print >>h, \
                  '<div class="%s">' \
                  '<a class="piclink" href="%s">' \
                  '<img class="piclinkimg" src="%s"' \
                  ' alt="%s" />' \
                  '<span class="piclinkspan">%s</span></a>' \
                  '</div>' % \
                  (stringjoin(divClass),
                   entityReplace(p.htmlName), entityReplace(p.thumbnailName),
                   entityReplace(p.imageName), entityReplace(p.imageName))
            if i % options.row == options.row - 1:
                print >>h, '</div>'
        # Ensure the last div is closed.
        if len(self.picList) % options.row != 0:
            print >>h, '</div>'
        print >>h, "</body></html>"
        h.close()


    # Comparisons assume that all the dirs compared are siblings (ie direct
    # children of one parent directory.)
    def __eq__(self, other): return self.dirBasename == other.dirBasename
    def __ne__(self, other): return self.dirBasename != other.dirBasename
    def __gt__(self, other): return self.dirBasename >  other.dirBasename
    def __lt__(self, other): return self.dirBasename <  other.dirBasename
    def __ge__(self, other): return self.dirBasename >= other.dirBasename
    def __le__(self, other): return self.dirBasename <= other.dirBasename


def dirTree(rootName='.'):
    '''Return a list of directory names starting from a specified root.'''

    def recursiveDirTree(rootName,dirName):
        '''Return a list of directory names.

        The directories are searched for starting from rootName/dirName.  The
        "rootName/" prefix is not included in names in the list.  dirName is
        included in the list.'''
        lst = []
        dirList = listdir(pathjoin(rootName,dirName))
        for d in dirList:
            if isdir(pathjoin(rootName,dirName,d)):
                dName = pathjoin(dirName,d)
                #message("Appending (%s) %s" % (rootName,dName))
                lst.append(dName)
                lst.extend(recursiveDirTree(rootName,dName))
        return lst

    lst = []
    if not isdir(rootName):
        return lst
    #message("Appending (%s) ." % rootName)
    lst.append('.')
    thisDirList = listdir(rootName)
    for subd in thisDirList:
        if isdir(pathjoin(rootName,subd)):
            #message("Appending (%s) %s" % (rootName,subd))
            lst.append(subd)
            lst.extend(recursiveDirTree(rootName,subd))
    return lst


def isPicFile(path, pic):
    '''Determine if a file is a known picture type.

    This currently only looks at the file name (actually the extension).  It
    should also identify the file contents, perhaps using Image methods?'''

    (base, ext) = splitext(pic)
    if ext in options.extensions:
        return True
    return False


def fileIsNewer(file1, file2):
    '''Return true if first named file is newer than the second.

    file1 and file2 can be names, or the results of calling os.stat().  If
    either file does not exist, we return false.'''
    if isinstance(file1,str):
        try:
            file1stat = stat(file1)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file1stat = file1
    if isinstance(file2,str):
        try:
            file2stat = stat(file2)
        except OSError,reason:
            if reason.errno == ENOENT: return False
            else: raise
    else:
        file2stat = file2
    return file1stat.st_mtime > file2stat.st_mtime


def doWebDirs():
    for d in webTree:
        # Handle '.' specially.  This is slightly icky.
        if d == '.':
            webd = webRoot
            picd = picRoot
        else:
            webd = pathjoin(webRoot, d)
            picd = pathjoin(picRoot, d)
        doOneWebDir(webd, picd)


def doOneWebDir(webd, picd):
    # First check that the directory still exists.
    if not isdir(webd):
        return
    if not isdir(picd):
        # There is no corresponding picture directory, so we recursively delete
        # the web output dir.
        deleteDir(webd)


def deleteDir(d):
    '''Recursively delete a whole directory tree.'''
    lst = listdir(d)
    for e in lst:
        p = pathjoin(d,e)
        if isdir(p):
            deleteDir(p)
        else:
            unlink(p)
    message("Removing directory %s" % d)
    rmdir(d)


if __name__ == '__main__':
    parseOptions()

    pd = PictureDir(picRoot, webRoot)
    pd.go()

    global webTree
    webTree = dirTree(webRoot)
    doWebDirs()

# arch-tag: dbd38a8f-6259-49ca-a125-6b5cd1f48bdb

