#!/usr/bin/python

import sys
import os
from optparse import OptionParser, Option, OptionValueError
from copy import copy



MyName = sys.argv[0]



class SppOption(Option):
    '''Extend OptionParser to parse image dimension specifications (AxB).'''

    def check_intpair(option, opt, value):
        intstrs = value.split('x')
        try:
            if len(intstrs) == 1:
                i = int(intstrs[0])
                ints = (i,i)
            elif len(intstrs) == 2:
                ints = ( int(intstrs[0]), int(intstrs[1]) )
            else:
                raise OptionValueError(
                    "option %s: Must be one int or two ints AxB: %r" % \
                    (opt, value))
        except ValueError,reason:
            raise OptionValueError(
                "option %s: not an integer or integer pair: %s" % (opt, value))
        return ints

    TYPES = Option.TYPES + ("intpair",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["intpair"] = check_intpair


opt = OptionParser(
option_class=SppOption,
version="%prog 0.1",
usage=
'Usage: %prog [options] picdir webdir.\n'
'  Recursively publish pics from picdir into webdir\n'
'\n'
'  Directories and pics from picdir will be mirrored into webdir, as\n'
'  thumbnails and small copies.  Symlinks will be used to point to the\n'
'  originals in picdir.\n'
'\n'
'  %prog can be run multiple times with the same picdir\n'
'  and webdir.  Pre-existing content in picdir that is still current will\n'
'  not have its webdir output regenerated.  Directories and images in picdir\n'
'  that no longer exist will have their equivalents removed from webdir.')

opt.add_option('-c','--copy',
               action='store_true',
               help='Copy originals instead of symlinking')
opt.add_option('--css',
               action='store',
               metavar="css_file",
               help='CSS file to use in html')
opt.add_option('-e','--extensions',
               action='store',
               help='Comma-separated list of file extensions to use.  '
               'Default=".jpg,.gif,.png"')
opt.add_option('-n','--no-symlink',
               action='store_true',
               help='Don\'t symlink originals')
opt.add_option('-q','--quiet',
               action='store_true',
               help='Don\'t print any output')
opt.add_option('-r','--regenerate',
               action='store_true',
               help='Force regneration of all output')
opt.add_option('-s','--thumbnail-size',
               type='intpair',
               action='store',
               help='Set maximum dimension for thumbnails (default 100x100 pixels)')
opt.add_option('-v','--verbose',
               action='store_true',
               help='Print more information about actions')

def parseOptions():
    global options, picDir, webDir, picTree, webTree
    (options, args) = opt.parse_args()
    if len(args) != 2:
        usage()
    if options.extensions:
        options.extensions = options.extensions.split(',')
    else:
        options.extensions = ['.jpg','.gif','.png']
    if not options.thumbnail_size:
        options.thumbnail_size = (100,100)
    options.messageLevel = 1
    if options.verbose:
        options.messageLevel = 0
    if options.quiet:
        options.messageLevel = 2
    picDir = args[0]
    webDir = args[1]


def usage(errcode=1):
    opt.print_help(sys.stderr)
    sys.exit(errcode)


def message(msg, level=1):
    if level >= options.messageLevel:
        print msg


def dirTree(rootName='.'):
    '''Return a list of directory names starting from a specified root.'''

    def recursiveDirTree(rootName,dirName):
        '''Return a list of directory names.

        The directories are searched for starting from rootName/dirName.  The
        "rootName/" prefix is not included in names in the list.  dirName is
        included in the list.'''
        lst = []
        dirList = os.listdir(os.path.join(rootName,dirName))
        for d in dirList:
            if os.path.isdir(os.path.join(rootName,dirName,d)):
                dName = os.path.join(dirName,d)
                #message("Appending (%s) %s" % (rootName,dName))
                lst.append(dName)
                lst.extend(recursiveDirTree(rootName,dName))
        return lst

    lst = []
    if not os.path.isdir(rootName):
        return lst
    #message("Appending (%s) ." % rootName)
    lst.append('.')
    thisDirList = os.listdir(rootName)
    for subd in thisDirList:
        if os.path.isdir(os.path.join(rootName,subd)):
            #message("Appending (%s) %s" % (rootName,subd))
            lst.append(subd)
            lst.extend(recursiveDirTree(rootName,subd))
    return lst


def doPictureDirs():
    for d in picTree:
        # Handle '.' specially.  This is slightly icky.
        if d == '.':
            picd = picDir
            webd = webDir
        else:
            picd = os.path.join(picDir, d)
            webd = os.path.join(webDir, d)
        doOnePictureDir(picd, webd)


def doOnePictureDir(picd, webd):
    '''Create one web dir from one picture dir.

    In here, the paths are full paths to the directories, so files can be
    opened using those paths, etc.  The roots have already been prepended.'''

    message(picd)
    if not os.path.isdir(webd):
        message("Creating %s" % webd)
        os.makedirs(webd)
    piclist = os.listdir(picd)
    for pic in piclist:
        if isPicFile(os.path.join(picd,pic)):
            print "pic=",pic
            doOnePicture(picd, pic, webd)


def isPicFile(pic):
    for e in options.extensions:
        if pic.endswith(e):
            return True
    return False


def doOnePicture(picd, pic, webd):
    print "Copying %s into %s" % (os.path.join(picd,pic), webd)


if __name__ == '__main__':
    global picTree, webTree
    parseOptions()
    picTree = dirTree(picDir)
    webTree = dirTree(webDir)
    #print "picTree=",picTree
    #print "webTree=",webTree

    doPictureDirs()
    for p in picTree:
        if not os.path.isdir(os.path.join(webDir,p)):
            message("Creating %s" % os.path.join(webDir,p))
            #os.makedirs(os.path.join(webDir,p))



# arch-tag: dbd38a8f-6259-49ca-a125-6b5cd1f48bdb

